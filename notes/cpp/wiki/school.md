
1. 动态内存
    1. 动态数组
        1. 如果可以使用std 的容器, 那么不用使用动态分配的数组
        2. 分配动态数组得到的为元素类型的指针
        3. 动态数组不是数组类型, 所以没有办法使用 范围for begin end
        4. 释放动态数组, 使用delete [] name; 如果省去[]的结果就是只有第一个元素被释放
        5. 对象数组数组分配的内存的时候, 需要调用对象的无参数构造函数
    2. new 
        1. new 在动态内存中间为对象分配空间并且返回一个指向该对象的指针
        2. 在动态分配的对象进行值初始化, 只需要在类型上面添加空括号 **原话位置**
            1. 对于定义了构造函数的class 类型, 两种初始化没有区别
            2. 内置类型:默认初始化为未定义
        3. 当提供了一个括号包围的初始器的时候,可以使用auto, 此时需要保证括号中间只有单一的初始器**原话位置**
        4. 使用new const 的时候必须显示的初始化**原话位置**
    3. delete 
        1. 接受一个动态对象的指针,销毁对象,释放关联的内存
        2. delete 的参数必须是动态分配的指针 或者空指针, 传递非指针导致错误,传递局部变量,或者重复释放后果未知
        3. delete 可以释放const 指针
        4. 内置的指针管理的动态内存必须显示的释放
        5. 释放了内存之后将指针设置为 nullptr 进而防止反复释放
    

    4. shared_ptr 
        1. 最安全分配和使用动态内存的方法: make_shared
            1. 混合的使用普通指针和smart pointer
            2. 不要轻易的使用get获取内置类型的指针,除非确定不会delete 和 赋值给smart 指针
        2. 将shared_ptr 存放在一个容器中间,对于不需要的元素erase
        3. 使用动态内存一个重要的原因是: 多个对象需要共享相同的元素
        4. 使用new 的时候, 直接初始化
        5. **P412** 有一个看的不是很懂的表格
        6. reset: 控制多个shared_ptr 共享的对象, 通常和 unique 一起使用
    5. **剩下异常**的部分, 而且还是不清楚如何处理delete 的问题 

2. exception
    1. throw
        1. 沿着调用链的函数可能提早的退出
        2. 一旦程序开始执行异常处理代码,沿着调用链创建的对象将会被销毁
        3. 异常如果没有捕获,那么将终止程序
    2. 异常对象
        1. **规定甚多**

3. namespace
    1. namespace无需添加 ;
    2. namespace可以不连续
    可以在一部分的位置申明原型, 然后在其他的部分定义函数
    3. using namespace A;  using A::find;  A::find();
    4. namespace 可以嵌套, 使用的时候为 A::B::find()
    嵌套的时候, 如果namespace A 包含有B , namespace 包含 函数C, 只有使用using namespace A::B
    或者 A::B::play ,或者 using namespace A; B::play() A::B::play, 也就是说含有屏蔽的作用
    5. using 可以随意的申明, 但是使用的时候也许会发生二义性错误,此时需要使用 作用域的符号进行修正
    6. A 包含 namespace B , 同时 Ａ中间含有　using namespace B, 那么using namespace A 可以让程序访问所有的位置
    7. 指定namespace 和 声明成员引用含有区别, 使用using namespace 还是可以使用 ::或者　A:: 来区分, 但是
    使用suing A::find; 之后, 不可以添加局部函数 find()
    8. namespace 可以使用别名, namespace ABCD = A::B::C::D
    9. 匿名空间的作用域为当前程序文件

    
4. misc
    1. constexpr
        1. const 表示为在 run time的时候确定的, constexpr int a = (a const int) 所以会报错
        2. constexpr 指针: 为0 nullptr 或者位置固定的对象, constexpr 为顶层const
    2. auto : **不会使用**
    3. decltype : **不会使用**
    4. typedef: 解析类型的方法不是简单的替换掉 和using在此处似乎没有什么区别
        1. 类中间 也是定义 typedef, 但是在其他的其他的位置使用的时候,使用 A::Integer 的方式使用,
        所以会有访问权限控制 
    7. 字面值: 算数类型 + 指针 + ref + (**0**) + (**0**)
    
    
6. string
    1. cin >> s; 遇到\w 停止 getline(cin, s) 获取一整行
    2. string::size_type
    3. 重载的运算符: >= > < <= + []
    4. 字符串相加: 两个字面值不可以相加
    5. for(char c: s) for(char & c: s) fori

7. vector
    1. 初始化的方法 () {} = ( , ) 区分元素的个数 还是元素的数值
    2. 支持操作push_back = size empty == >
    3. vector<int\>::size_type;
    4. 不可以通过下标添加元素

6. 数组
    1. 数组维度必须在编译的过程中间确定, 所以不可以使用的const int 来初始化
    2. 没有引用的数组, 但是数组的可以有ref
    3. 数组类型不可以使用 auto 进行推断
    4. 字符数组可以使用字符串进行初始化, 但是需要注意字符串的结尾字符
    5. 数组不可以赋值和拷贝
    6. **3章 105**之后没有看
    7. 在函数传递参数的时候, 数组会转化为指针, 所以[] 中间有没有数值含义相同, 但是含有高维的时候, 
    [] 中间的数值表示了类型, 不可以省


9. C++ 初始化对象的方式有哪几种 ?

10. 左值 右值 reference
    1. r-value: contents , l-value: location
    2. C++ 11 增加了右值引用, 不特殊的说明, ref 表示左值
    3. reference:
        1. reference 始终绑定到相同的对象上面, 所以没有申明的时候一定要初始化
        2. reference 不是对象, 所有没有办法定义ref of ref
        3. reference 只可以绑定在对象上面, 没有办法绑定在 字面值 或者 表达式的计算结果上面 
        4. const ref 可以和任何的右值进行绑定
    4. 位段成员没有引用, 但是寄存器变量可以有引用
    5. 指针不可以指向引用变量, 原因A pointer needs to point to an object. A reference is not an object.是
    6. 引用的数组, 数组的引用 int (&a)[12]  int & a[12]
    7. 不可以引用 一个 引用



11. 析构函数
    1. The destructor default is inappropriate to polymorphic classes, requiring an explicit definition.
    2. 析构函数释放的内容是什么:
    3. 析构函数和继承
        1. 析构函数最好是定义为虚函数, 为了实现动态绑定, 从而可以将所有的位置的内容全部的释放
        2. delete 删除的为pointer, 所以实现的方法为:
            ```  
            Life *  life = new Endless;
            delete life;

            Life & life1 = *new Endless;
            delete &life1;
            ```
    4. 析构函数可以定义为纯虚函数
    5. 最先定义的对象最后释放
    6. 不同的返回值的影响:
        1. 所有的全部回收 return
        2. 全部不回收 abort
        3. 回收静态变量 和 全局变量 exit
    7. 不可以取出构造函数的地址
    8. 析构函数不可以重载

     

12. const
    1. const var 不可以重复赋值, 此处var包括 pointer 类型
    2. pointer to const 不可以修改指向的数值
    3. const 申明立刻初始化
    4. 分析的时候,从右向左的边:
        1. const int a = 12; int const a = 12; 都是合法的
        2. const int * p; int const * q; 和 int * const r; 不相同的
    5. reference 和 const :
    int i = 12; 
    const int &j = i;
    int const &h = i;
    int & const g = i;
    第三种方式是不要使用
    6. const int const * a; 错误的申明方式


    

13. 函数
    1. 默认参数类型: 
    2. 局部静态变量: 
        1. 如果没有初始化, 默认初始化为0
        2. 程序结束的
    3. 函数申明
        1. 定义了函数的源文件应该把函数申明的头文件包含进来
    4. 使用ref para 实现多个返回值
    6. 使用常量ref的好处:
        1. 可以保证实参不会修改
        2. 保证函数同时可以接受 const 和 非const 的参数
    7. 数组parameter:
        1. 不允许拷贝数组
        2. 数组会被转化为指针
        3. ref array 参数的函数的申明: void print(int (&arr)[12])
    8. 参数数目没有办法事先确定
        1. 如果参数类型相同, 使用initializer_list
        2. 参数的类型不相同, 使用可变参数模板
        3. 省略符形参, 针对C的接口
    9. 不要返回局部对象指针 或者 ref
    10. 列表初始化返回值
    11. main 函数不可以调用自己
    12. 返回值为函数:
        1. 使用 typedef 或者 using:
        2. Type (* function(para_list))[dimension]
        3. trailing return type
        4. decltype
    13. 重载:
        1. 函数的名称相同, 函数的形式参数列表不相同
        2. const 和 重载
            1. 顶层const 不会影响传入的对象(由于指针是不是常量, 对于指向的对象是没有影响的)
            所以顶层const 的函数不会重载
            2. 如果const是某种类型指针 或者 ref, 那么可以通过底层const 实现重载
        3. 重载和作用域: 如果在内层作用域中间申明了名字,他将会隐藏外层作用域中申明的同名实体.
        不同的作用域中间无法重载函数名. 由于名字的查找会在类型检查之前, 也就是在当前的作用域的范围中间检查了
        4. 
        之后,得到了函数名称之后, 然后就开始类型判断 !
    14. 默认实参数
        1. 函数调用的时候按照位置进行解析, 默认实参数负责填补函数调用之后缺少的尾部augment
        C++ 的函数调用没有python的键值对的方式
        2. 默认参数的申明 和 非默认参数的申明的位置 不是随意的, 默认参数之后必然都是默认参数
        3. 默认参数不会区分重载函数
        4. 可以使用任意的表达式来表示参数, 但是不可以使用同一个参数列表的中间的数值, 放置出现计算法顺序的不同导致的问题
        5. 不可以在申明 和 定义都定义缺省参数的数值
    15. inline
        1. 避免调用函数调用的开销
        2. inline 只是一个请求, 编译器可以忽略
    16. constexpr
    17. 函数匹配:
        1. 当一个函数满足两个条件: 每一个实参不差于其他的函数的实参 并且 至少有一个实参笔其他的所有实参都
        要好的时候, 那么该函数满足条件. 如果不满足, 那么将会汇报一个二义性错误
        2. 对于底层const, 含有偏好
    18. 函数指针
        1. 函数指针的类型由形参类型 和 返回值返回值确定
        2. 赋值: & 可选
        3. 不同的函数指针之间没有转换规则, 只有类型相同才可以赋值
        4. 对于重载函数, 也是支持函数指针的赋值的, 但是需要精确的指出该类型

    

14. 求值顺序 运算顺序
    1. left-to-right right-to-left : Operators that have the same precedence are bound to their arguments in the direction of their associativity.
    也即是出现相同的运算的级别的时候, 整个公式从那一边开始运行的
    2. 常用的顺序:
        1. [] 强于 *

15. 继承
    1. 访问限制
        1. 派生访问控制符: 控制derived class 用户, 也就是说在class 的内部随意使用, 但是外部需要
        使用筛子, 派生访问控制符: 设置为用户的 !
        
        2. 如果需要单独的访问某一个private
        3. 通过类顺序
        4. 析构函数 和 构造函数
        5. derived class 访问 base class 中间的protected ,只有通过derived class的对象, 而且普通base class 成员不具有特殊的访问权限
        6. 只有为public 的继承的时候,用户代码才可以使用从derived class 到达 base class的转换
        7. **P544 派生类向base class 转换的可见性**
        8. 友元关系不可以继承
        9. 使用using 可以实现修改部分访问控制,从而打破继承访问控制符的一刀切的问题,但是using 仅仅对于自己可见的对象而言的, 以前语法可以省去 using, using只可以回复, 而不可以改变
        10. 派生类的作用域位于base class 的作用域中间, 派生类的同名成员会隐藏base class 的成员
            1. 此规则适用于函数, 即使参数列表不同, 只要是同名,也是会把base class的成员屏蔽
            2. 可以使用作用域运算符实现对于隐藏的元素访问
            3. 隐藏的含义不是屏蔽,清除, 隐藏对于使用者不可见,但是子类依旧可以继承
            4. 继承的前提是参数列表 和 返回值 相同, 如果参数列表不相同,那么为屏蔽
        11. 编译的时候对于名字的查找,对象 指针 ref的静态类型决定了对象的那些成员可以使用
        12. 覆盖重载函数:派生类 如果需要所有的重载函数都是可见,要么覆盖所有的版本,要么全部都是不可以覆盖的
        13. 访问限制对于构造函数相同有效, 如果申明了private构造函数,那么子类将初始化
        14. **拷贝部分没有查看**
        15. using 
            1. using的使用为配合派生访问控制符号, 让用户使用子类的继承父类的成员可以更加灵活
            2. using 放置的位置为重新修正的位置
        16. 如何理解私有函数的override:
            1. **既然该函数无法访问, 为什么还是可以重载**
            


    2. virtual override final
        1. override 告诉编译器此函数为重载的函数
        2. virtual  表示此函数可以被继承
        3. virtual 不可以出现在class 的外部
        4. 子类中间override 的函数默认为 virtual的
        5. final既可以修饰 class  也是可以修饰函数, 但是不可以修饰成员变量, final 放置的位置都是后置; class Name final: BaseClass
        6. 
    3. base class 通常需要定义一个虚析构函数

    5. derived class 构造函数: 使用委托构造函数, 首先初始化base class部分
    6. static: base class 以及所有的 derived class 都是共用相同的 static variable
    7. derived class 声明的时候不可以携带继承列表
    9. 类型转化
        1. derived class convert to base class 只有对于指针 和 引用类型有效
        2. base to derived 没有隐式的转换
        3. derived to base 会有访问权限的限制
        4. 对象之间不存在类型转换,而是赋值构造函数(此处对象 表示和 指针 ref 向对应的概念), 
    10. 虚函数
        1. 必须有定义
        2. 虚函数返回值的类型 需要 和base class中间的保持一致, 除非返回值为类的指针或者ref(此处需要说明是: 类的指针是当前的类 或者 base class)
        3. 默认实参: 最好base class 和 derived class 的默认实参保持一致
        4. 使用 作用域运算符 实现强制使用 base class
        5. 纯虚函数:
            1. 含有纯虚函数的类为抽象base class
            2. 没有实现继承的纯虚函数的类还是 base class
            3. 纯虚函数定义方法 =0, 但是需要注意的是, 只有当该函数确定为virtual 的时候才可以添加 =0; 
        6. 虚base class 和 抽象base class:相同的东西 

    
    11. 多继承
        1. base class的构造顺序和派生列表中 base class 出现的顺序相关
        2. 类从 base class 中间继承了多个相同的构造函数, 必须定义自己的构造函数加以屏蔽
        3. 析构函数
            1. 派生类的 析构函数仅仅负责自己的资源
            2. 析构函数的调用的顺序和构造函数相反
        4. 拷贝 复制 移动 **712**
        5. 对象 指针 ref 的静态类型决定 可以访问的成员, 但是访问函数的时候,一旦返现该函数被继承了
        而且函数动态类型为派生类的,然后就可以动态绑定
        6. 作用域
            1. 如果含有过个变量, 同时派生类没有屏蔽该变量, 会导致二义性
            2. 参数列表不相同可能还是会导致错误
            3. 即使base class 中间为private 的,依旧可能导致错误
            4. 所以最好定义自己的版本
        7. 虚继承
            1. 默认情况,如果base class在子类中间出现多次,那么会导致派生类含有多个子对象
            2. 虚继承在于影响派生类中进一步派生出来的类, 例如A:virtual B{} 表示如果以后有 类C来继承 A, 那么C中间持有的类 B 将会是虚基类, 和其他的继承
            可以实现公用.
            3. 一个类不可以继承继承两次, 在这两种语法下面 Fuck: Amazing , Amazing  和 Fuck: Amazing, virtual Amazing
            但是B:A{} C: B, virtual A{} 或者 C: B A{}
            4. 理解 虚基类 和 同名基类: 独立存在
        8. 虚基类  AmphibiousVehicle: LandVehicle, WaterVehicle 例子中间
            1. 初始化AmphibiousVehicle 的时候 实现了对于 虚基类 Engine 的初始化
            2. 类的初始化的顺序首先是 Engine 然后按照列表的顺序
            3. 通用法则是: 首先检查所有的虚基类，将虚基类初始化, 然后逐一初始化其他的部分!
            4. class Engine’ is both a direct base and an indirect virtual base
            5. 虚基类解决的问题是: 多个路径之下, 没有必要包含同一个base class
            
            
    12. 构造函数
        1. 一个类仅仅继承 直接base class的构造函数, 通过使用using 来实现, using 的作用相当于
        产生为base class 的所有
        2. 类不可以默认 拷贝 和 移动构造函数
        3. using 对于构造函数使用不会改变构造函数的访问权限
        4. 对于含有默认构造函数的, 派生类可以得到多个继承的函数
        5. 如果派生类和子类含有完全相同的参数列表, 那么不会继承该构造函数
        6. 构造函数的继承
            1. 获取相同参数列表的base class的函数 + 该函数持有初始化的列表
            2. 构造函数的继承体现于生成代码, 多继承会出现反复定义的问题
            3. 如果定义了自己的构造函数对于base class 中间的函数进行压制, 
            那么继承的构造函数是完全不可以访问的, 和普通函数继承同时定义自己的同名函数不同, 
            后者是而已通过作用域符号访问的
        7. 只要base class explicit 的声明过构造函数的时候, 才是可以适应using Base::Base
        8. 构造函数 不可以为 virtual, 之所以使用的virtual,由于为了在是使用的时候不关心具体类型, 
        这和构造函数的目的冲突
        
    
    13. static
        1. 在类的内部使用static 关键字声明 , 在类的外部不可以使用关键字进行初始化
        3. 最好把类的静态数据成员和其他非内联函数放到相同的文件之中
        4. 静态成员可以成为的默认实参
        5. 静态成员可以是不完全类型
        7. 静态函数
            1. 静态函数定义位置：
            2. 
        8. 静态成员也是满足访问控制
        9. base class 中间定义了静态成员之后, 整个继承体系中间只存在该成员的唯一的定义
        10. 局部类 和 Union 都是不可以包含静态数据成, 但是可以包含有静态函数
        11. const volatile 用于修饰成员函数, 所以和static 不可以共存
        12. 静态变量在类中间申明, 在类外面初始化, 只有没有初始化的时候定义才会出现错误
        13. A 含有 成员B ,如果B 中间的成员, 如果B 是一个static 的变量, 那么即使B 没有无参数构造函数,
        A一样可以只有无参数构造函数,应为B 的初始化的位置在外部
        14. 成员静态函数 和 成员静态变量相同, 在文件中间申明的时候含有 static, 但是定义的时候不可以含有的
        static , 但是静态函数成员的可以定义在函数体中间, 但是变量不可以定义在函数体中间
       

        
            
16. 运算符重载
    1. 除了重载的函数调用运算符operator()之外,其他重载运算符不可含有默认实参
    2. 重载不改变优先级
    3. 重载参数的数目相比运算的数目少一个
    4. 不可以重载的运算符 . .* ?: :: 出于其他的原因, 还有一些不建议使用
    5. 根据使用选择到底是成员函数 还是非成员函数来重载
    6. 运算符号重载的理解的关键在于: 和普通的函数没有区别, 如果有, 那就是符号带来的
        1. 符号的运算的顺序
        2. 普通函数 和 成员数
        3. 访问权限
        4. 友元
        5. 继承 
        6. 静态
        
    7. void operator++(int)’ must have an argument of class or enumerated type
 void operator ++(int a) 显然不允许重载内置类型的运算符
    6. **一下为问题**
    7. 如果重载 ++ 的时候, 如果想要实现 a ++ 怎么班(实现从在 ++a,仅仅为 int operator ++())
    8. 含有的对象的重载和普通的重载在表达上面有什么区别,或者 this 的省去代表了什么 ?
    9. 应该是没有静态重载运算符 的吧 !
    
    

17. 复杂类型
    1. int * p, q 注意 q 是一个整数
    2. [tutorial](https://www.codeproject.com/Articles/7042/How-to-interpret-complex-C-C-declarations) right left rule

18. 左值 右值
    1. A  kk = A(1, 2); A& jj = kk; 不可以写成 A & kk = A(1, 2); **why**
    2. 
 

19. class
    1. 定义在class 内部的函数默认为inline
    2. this 为常量指针
    3. const 成员函数:
        1. 调用const 成员函数, this 表示为指向常量的常量指针,也即是const 函数不可以修改对象的内容
        2. const 成员函数如果返回的this*, 那么得到也是常量, 当然返回值的声明为 const
        3. 对于非成员函数没有 void non() const; 的操作
    4. 构造函数
        1. 构造函数没有返回值
        2. 构造函数不可以为const 类型
        3. 默认构造函数
            1. 只有么有声明任何构造函数的时候才会自动被创建
            2. = default
            3. 使用默认构造函数不可以带括号
        4. 构造函数初始值列表
            1. 如果成员是ref 或者 const 的时候, 当成员为没有定义默认构造函数的class类型的时候,必须对其初始化,
            但是构造函数一开始执行的时候,那么初始化就是完成了,所以初始化列表为出始化的唯一机会

            2. 列表的顺序和定义的顺序最好相同
            3. 最好不要使用一个成员初始化另一个成员,后果很难预料
            4. 初始化的顺序和成员定义的顺序相同
            5. 如果构造函数为所有的参数提供了默认的实参,那么实际上定义了默认构造函数
            6. 初始化列表中间的数值不仅仅为字面值 而且可以是 表达式 以及 函数
        5. 委托构造函数: 先执行被委托的构造函数的初始值列表和函数体,最后执行委托者的函数体
        6. base class doesn't have default constructor:
            **有必要指出部分的问题** 应该是无论base class 是否含有构造函数的时候,都是会首先执行base class,
            只是在构造函数的初始化的列表上面的, 如果base class 没有默认的构造函数, 同时也初始化的列表上面也是不申明的话,
            那么会有报错 !
             
            1. 所有子类的函数都需要调动父类的构造函数，然后在执行自己的部分
            2. 如果base class 中间没有default 的函数 或者 参数列表为空的函数, 那么可以在初始化列表的位置使用其他版本的函数
            3. 初始化的列表中间只可以初始化自己的变量 不可以初始化父类的变量, 这里父类变量不仅仅是父类的private变量, 而是所有的变量
            , 在初始化的列表上面初始化的结果: error, 没有这一个的变量 !
        7. default 和 参数列表为空的函数, 在使用上面没有区别, 但是效率不同
        8. 构造函数的初始化顺序: 首先执行虚基类, 然后基类, 然后按照成员的申明的顺序执行
        (构造函数的初始化列表的作用在于指定初始化成员变量的方式)
        9. 使用 花括号 申明 : 如果类的所有的成员都是的public 的，　而且没有定义构造函数，那么使用｛｝初始化，　初始化的标准和　Ｃ相同

        
    5. 友元
        1. 一般来说, 在类的开始的位置 或者 结束前 位置 集中的定义友元. 但是友元的申明必须定义在类的内部, 使用的friend的 作用在于制定friend
        而不是自己申请的friend !
        2. 友元的申明: 两次声明, 即使在类中间声明过, 但是类成员调用依旧是依赖于在外面的声明
        3. 其他类成为友元
        4. 其他类的函数为友元:　不可以申明其他的static　为友元
        5. 其他的函数为友元:普通的函数申明的方法为: 
        6. 对于重载函数, 友元需要一一说明, 由于重载函数的本身含有参数列表的不同, 所以很容易理解可以 和 需要 一一说明
        7. 友元和作用域:
            1. 设置某一个成员函数为友元: 假设 B 需要持有 A的函数 func(), 那么首先定义B, 申明函数, 然后定义A, 最后定义B 中间需要使用的func() 的函数
            2. friend func() 只是表示的对于函数func() 为当前类的友元, 但是不是表示当前的类成员可以看到该函数
        8. 理解什么叫做可以访问A 的 private 变量: 该友元可以使用 . 加上 A's private part
        9. 友元函数可以在类里面定义函数体, 那么函数自动为inline 函数
        10. 友元不是对称的关系,友元也不可以传递
        11. 申明其他函数为友元, 前提其他的函数可以访问的

            

    6. 定义类型
        1. typedef 或者 using
        2. 先定义 后使用
    7. inline 成员函数定义在定义class所在的头文件中间
    8. 可变数据成员: 希望修改某一个成员, 即使该成员在const 成员函数的位置, 使用mutable 关键字实现修改
    9. 返回值为 this* , 如果返回值为 ClassType, 那么将会得到一个复制版本,所以一般返回为 ref
    10. 重载函数, 非常量 和 常量对象可以各自调用自己的函数
    11. 类的作用域: 
        1. 遇到类名称,定义剩下的部分包括参数和函数列表都是作用的范围之中,但是不包括返回值
        2. 尽管类的成员名称和外部对象重名会导致外部的对象被屏蔽, 但是可以使用作用域运算符进行请求
        3. 编译器处理的顺序为: 首先处理所有的变量, 然后处理函数 !
        4. 典型例子: 如果函数变量为 height,成员变量含有 height, 同时还有一个全局变量为 height
        ,在该函数中间实现访问的方法为: this -> height ClassName::height 对于全局的访问::height
    12. 隐式的类类型转换
        1. 可以通过一个实参的构造函数定义一条从构造函数的参数类型向类类型隐式转换的规则
        2. 使用explicit可以对于只有一个实参构造函数的隐式转换进行阻止
        3. 可以对于explicit 修饰的构造函数进行 显式 的转化
    13. 聚合类
        1. 所有的成员为public
        2. 没有定义任何的构造函数
        3. 没有类内初始值
        4. 没有基类 和 virtual
    14. 字面值常量类
        1. 数据成员都是字面值常量的聚合类
        2. 满足一下要求
            1. 数据成员为字面值常量
            2. 至少含有一个constexpr的构造函数
            3. ...
            4. ...
    
20. 泛型算法
    1. 迭代器
        1. 如果容器为空,那么begin() 和 end()  将会返回相同迭代器, 即为off-the-end iterator
        2. 支持的操作: ++ -- * == !=
        3. 不要在使用了迭代器的for中间添加减少元素
        4. vector string 的支持 -= += > <= + -
        5. cbegin() cend()
        
21. 作用域
    1. :: 为单目 和 双目 运算符, 单目用于全局标识符
    2. 
22. 成员指针
    1. 普通成员指针是一个偏移量, 存放不是成员的地址, 不可以移动
    2. 使用普通成员指针的时候必须和对象关联
    3. 普通成员指针通过 .* 和 ->* 访问, 普通的指正使用 * , 两者之间不可以混合的使用
    对于A, 如果有int A:: **a 和 int A:: * A:: * a 的访问的方式不相同
    指针的申明方式和 对象没有关系, 但是指针获取对象的
    假设A 含有变量的 x, A 有一个成员为a, 那么 &A::x 得到为 int A:: *x;  & a.x 得到为 int *

    4. 普通成员指针不可以进行类型转换

23. 内联函数
    1. 内联失败: 成员函数含有分支结构, 定义在使用之后, 取函数地址, 定义虚函数之后,内联失败
    2. 函数中间的的类自动内联, 由于作用域的问题, 函数中间的类只有可以定义在类中间的, 所以自动内联.
    需要指出的是, 在类中间定义的类的成员函数没有必要一定定义在类中间
    3. 匿名类: 由于没有名称, 所以没有办法在外部定义该名称

24. virtual friend static 互相冲突
    1. virtual friend:  
    2. virtual static 显然
    3. friend static : 不可以
    4. 虽然friend 和 virtual , static 都是冲突的, 但是实际上类A 的普通函数, 静态函数, 虚函数 , 构造函数, 析构函数
    都是可以定义为
question:
1. 如果base class 的函数只是declare了, 继承如何处理 !
2. 如果两个函数没有继承关系, using Base::Base; 是什么含义？
3. 条目 19.7 **trivial** 是什么
4. 哪一个位置指出 析构函数的 权限不同的
5. 静态变量在class 中间定义
6. 静态函数哪里定义过
7. 拷贝函数默认形式是什么, 深度拷贝如果参数为const 非要使用 const_cast , 
拷贝函数是不是一般使用 = 重载,  那么赋值和 =  的关系是什么 ?
8. 拷贝函数和赋值函数有什么区别 ?
9. 检查清除到底那些需要在函数初始化列表中间初始化的
11. 如果定义了对象的赋值, 那么对象的指针的 = 也是被重载的吗? 
12. 那么如何强行使用系统 = 即使 = 已近被重载的情况下
14. 假定已经定义了一个类Code , 那么 const Code code; 的问题在于何处　？
15. base class 的虚函数 : 什么时候会用到 ? 如果base class 定义了private 的纯虚函数 ?
16. 123页ppt 虚函数导致内联失败
17. 103 using 的作用是恢复  ? 
18. derived class 的析构函数为什么必须添加 virtual
20. 命名空间 如何理解 分析 和 解释 ? 
21. 间接移动指针
24. 45  匿名内联只可以定义公有数据成员, 公有是什么意思 ?  最后的 这一份代码没有办法编译  !
26. 20 枚举完全编译不通过 !
27. virtual static friend 互相不兼容
28. static 函数 为什么 会出现inline 失败
29. static 函数定义的位置有没有特殊要求
30.  





some rules picked up:
1. this 不可以进行赋值, 但是 *this 可以
2. const ref 和重载的问题
3. 如果使用拷贝函数 和 赋值函数, 必定不是为了实现shallow 的拷贝, 实现的含有相同的数据,但是
各自持有各自的内容, 也就是没有指针赋值的问题
4. copy 是为了创建新的对象,而assign 是针对已经含有的对象修改其中的数值


**据说 derived 的访问权限有不同 地方, 尤其在于继承的时候**

