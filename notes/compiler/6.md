# 6 LR分析
1. LR分析法的规约过程是规范推导的逆过程
## LR分析概述
1. LR分析器三个部分构成
    1. 总控程序(驱动程序)
    2. 分析表
        1. 动作表 GOTO
        2. 状态转化表 ACTION
            1. sn 将符号a, 状态n压入栈中间
            2. rn 使用第n个产生式进行规约
    3. 分析栈
        1. 符号栈 X
        2. 状态栈 S
2. 四种状态
    1. 移进
    2. 规约
    3. 接受
    4. 报错

3. 在规范句型之前，形成可规约的前缀之前包括可规约前缀在内的所有前缀都称为**活前缀**

4. 规范规约


## LR(0)分析
1. LR
    1. L 对于输入从左到右的扫描
    2. R 反向构造一个最右推导序列
2. k = 0 和 k = 1的时候含有实际意义，缺省为 1
4. 规约的过程
    1. 规约的时候，同时删除状态
    2. 规约结束符号　和　查询GOTO表格　计算出来一个新状态, 并且push到stack中间
    3. 根据当前的状态　和　等待移入　终结符确定　新添加状态
5. LR(0) 项目　: 将右部某位置有圆点的产生式称为相应文法的一个LR(0)项目，　简称项目
    1. 项目描述句柄的识别状态
    2. 项目分类
        1. 移进状态 : 点在前面
        2. 待约状态 : 点在中间
        3. 规约状态 : 点在最后面的位置
    3. 空产生式只有一个项目　A -> Point
    4. 后记项目 : 同一个产生式，圆点的位置相差一个
6. 增广文法　添加一个S -> S' 的文法
    1. 文法开始符号只出现在一个产生式的左边，从而让分析器只有一个接受状态
7. 每一个项目的含义和圆点的位置有关，圆点前面的位置表示分析的过程的某时刻准备使用的该产生式
规约的已经识别过的句柄部分，圆点后面的部分表示期待的后缀部分
7. 项目集闭包
    1. 计算LR(0)自动机
        1. 将点向右边移动一个位置，如果点后面为非终结符, 那么非终结符的
        所有的产生式
        2. 如果当前为规约状态，那么没有后面状态
    2. 通过LR(0)自动机计算分析表
        1. CLOSURE(I) 项目集 I 的闭包 : I中含有A-> a * Bb,那么添加所有B的产生式到项目集中
        2. GOTO(I, X) 返回项目集 I 对应于文法符号X的所有的后继项目集闭包
8. 规范LR(0)项集族
    1. LR(0)分析过程的冲突
        1. 移进规约　冲突
        2. 规约规约　冲突
    2. 如果LR(0)分析表中间没有语法分析动作冲突，那么给定的文法为LR(0)，　上下文无关文法不总是
    一个LR(0)文法
9. SLR分析
    1. 是否为句柄的决定了当前是否采用规约的动作, 利用FOLLOW集合来分析上下文
    2. 算法
        1. 当含有移进项目点　后面的含有的符号为ai, 当规约项目左边为Bj, 根据添加进入的符号
        a, 如果属于ai中，使用移动进入，否则使用规约

10. LR(1)分析方法
    1. SLR的问题 : SLR只是简单地考察下一个的输入符号b是否属于规约项目Ａ-> a, 关联的FOLLOW(A),
    b属于FOLLOW(A)只是一个必要条件，而非充分条件，当b是A的FOLLOW集合的时候，其实不可以说明什么
    但是当b不在A的FOLLOW集合中间，如果遇到了b, 一定不可以进行规约的，所以即时是FOLLOW集合也是不可以进行
    规约的

    2. 实现FOLLOW集合将不同的位置　上面的拆分

11. 如果除去**展望符**之外，两个LR(1)项目集是相同的，那么称这两个LR(1)项目是同心的
12. 为了计算LR(1)项目集闭包，相对于LR(0)的closure函数做出修改
```
    set_of_items closure(I){
        repeat for(I 中间的每一个项目　Ａ-> m * Bn, a)
            for G 中间的所有的产生式　B-> k
                for First(na) 中间的每一个符号ｂ
                    将Ｂ->*n, b 加入到集合I中间
        until不可以添加更加多的符号
        return closure(J)
    }
```
13. LALR算法使用：LR(1)算法的导致状态的数目过多
    1. 寻找具有相同核心的LR(1)项集，　并且将这些项目集合并为一个项集
    2. 合并的时候会出现的规约规约冲突
    3. 合并的时候不会发生移进　规约冲突，由于展望符　只有在规约的时候起作用
    4. 会导致的错误发现的时间延迟

14. LALR(1)的特点
    1. 在形式上面和LR(1)相同
    2. 大小和LR(0) 相当
    3. 分析能力在SLR 和LR(1) 中间

15. 深入理解冲突形成原因
    1. SLR出现的原因，在一个项目集中间，SR(0)指出，当前为规约项目的时候，那么遇到的所有的非终结符处理方式
    都是规约，但是如果规约项目和待约项目同时在一个项目集合中间

16. SLR处理移入－规约冲突的方法
    1. 当规约项目的左部S的FOLLOW集合不包含所有移进项目的移进项目的时候，那么冲突可以处理
    假设S的FOLLOW集合不包含符号a, 那么当前必定不可以规约，否则会出现Sa的情况，也就是说
    只有的FOLLOW集合才可以出现，所以采用移进
    2. 出现多个规约项目和多个移进项目的时候，要求所有移进符号集合和所有FOLLOW集合两两之间没有交集
17. SLR(1)不可以处理原因是什么:
    1. 注意到并不是FOLLOW(A)的所有元素在含A的所有句型中，在A的后面都会出现，如果d 仅仅在规范句型aAd中间出现
    那么当面临符号d的时候才应该规约
    2. 当[A-> a\*BP] 属于项目集I的时候，那么B->\*K也是属于项目集I, 将FIRST(P)作为用产生式B-> K的规约　搜索符号

18. LR(1)项目集的构造方法
    1. lookahead符号表示当前的符号后面紧跟的符号
    2. lookahead 的出现减少规约的时候后面出现符号的数目，使用了上下文的信息，而不是仅仅使用全部的FOLLOW集合内容
    3. 所以问题的关键变化成为计算lookahead的方法:
        1. 当A-> b * B * P ，a 其中有　B -> M, b 那么计算lookahead b的原理是 b 需要成为　Pa的前面数值

## Ques
2. 反向构造的最右推导
3. 句柄 => 定义是什么？ 为什么说， 每次规约的符号串称为句柄
4. × 很显然如果可以同时满足多个，那么如何处理 ？
5. 规范句型是什么东西 ?
6. GOTO 和 ACTION 表中间的含有内容是什么　？
7. 自动机得到分析表的过程，是不是改行如果有一个含有规约，那么所有都是
规约，或者说，当前仅当规约状态的时候，那么该行所有的都是规约，而且采用的规约产生式都是
相同
8. 为什么从自动机变化成为分析表　？
9. https://www.icourse163.org/learn/HIT-1002123007?tid=1002655021&edusave=1 这一节已经完全不知道在说什么了
10. 迷一样活前缀定义？
11. 活前缀的构造方法是否的要求掌握，它和规范集的构造联系是什么？

12. 根据分析表的结构, ACTION表的列全部都是终结符，而GOTO表中间全部都是非终结符,其中原因是
ACTION的含义是当栈中间遇到了一个终结符的时候，是移动当前字符，还是当前的以及前面的字符进行规约，并且确定栈里面的
状态是什么，如果当前移入的符号导致规约，那么规约的非终结符A会去处理GOTO[n, A], 其中n表示规约之后状态栈指针下移动k
个单位暴露出来状态，由于ACTION处理移动非终结符的动作，GOTO处理的规约之后，移动进入状态
    1. 规约状态的处理结束之后，用于触发规约的非终结符开始添加
13. 从识别活前缀的DFA如何得到对应分析表
    1. 对于GO(Iｋ, x)的处理，如果x是一个终结符，那么添加一个ACTION，如果是非终结符，添加一个GOTO
    2. 规约状态，所有终结符全部添加一个rx, 其中x表示规约状态对应的式子的编号
    3. 当目前的状态的进入到达规约状态的时候，使用当前的公式进行规约，符号栈的顶部出现规约式的左边的非终结符, 标记为Ａ, 此时状态栈上面出现的状态为在收集了整个产生式的右边之前的一个状态，而GOTO表中间的内容恰好提供状态转换关系

14. 关键的问题
    1. LR成立的条件是什么？
    2. SLR(1) 处理问题的时候，出现问题原因从句柄角度分析
15. 多余规约
    1. 是不是只会出现将本来应移进错误的识别为规约而不是反之?

16. 为什么LR文法切换了项目集的构建的方法就处理了SLR不可以解决的问题？

17. 如何发现当前SR文法含有冲突？
