# 散列表
## 直接寻址表

## 散列表
在直接寻址表中间 关键字为k 的元素放置到 k 的位置，但是在散列表中，放置到h(k)的位置

collision ：减少冲突发生的概率 处理冲突

链接法

装载因子 alpha

成功的查找和不成功的查找都是 1 + alpha
> 其中不成功的查找的证明很有意思


## 散列函数
除法散列
乘法
全域

好的散列函数： 相似的关键字的散列值截然不同 independent of any patterns that might exist in the data
> 这两条我都是看不懂的，觉得可以简单均匀散列就是可以了啊

除法：不接近2的整数幂的素数

乘法：Knuth
> 迷之建议

全域散列：随机的选择散列函数，使其独立于要存储的关键字

函数组是 universal 的表示：
:confused: p149 - p151 由于睡觉，耽误了

## 开放寻址法
不使用指针，而是计算出要存储的槽序列

probe： 检查的顺序依赖于等待插入的关键字
均匀散列： 任何关键字的探查顺序为<1....m> 的重新排列的一种

线性探查：

二次探查

双重探查

th11.6 不成功的查找, 插入为 1/(1 - alpha)
:confused: 习题和 11.6 以及 11.7 没有处理

## 完全散列
:confused: 此小结没有看
:confused: 本章的习题没有处理
